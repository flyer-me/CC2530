//-------------------DMA TESTING -----------------//
/******************************************************
实验内容： 设定DMA
当检测到按键S1时，设定DMA从RAM里转出数据，如果成功，则
点亮LED3并在c串口上提示 Correct， 否则提示 Error
******************************************************/

#define LED1 P1_0       //定义P1.0口为LED1控制端
#define LED2 P1_1       //定义P1.1口为LED2控制端
#define LED3 P1_4       //定义P1.4口为LED3控制端

#define KEY1 P0_1       // P0.1口控制按键KEY1

#include "hal.h"
#include "hal_types.h"
#include <string.h>
char  titleString[] = "-------- DMA Testing --------";
char  hintString[]  = "...Push KEY1 to start DMA ...";
char  goodString[]  = "...yes, DMA transfer correct";
char  badString[]   = "...bad,DMA transfer Error";



/****************************************************************************
* 名    称: LedOnOrOff()
* 功    能: 点亮或熄灭所有LED灯    
* 入口参数: mode为0时LED灯亮  mode为1时LED灯灭
* 出口参数: 无
****************************************************************************/
void LedOnOrOff(uint8 mode)
{
    LED1 = mode;
    LED2 = mode;
    LED3 = mode; 
}


/****************************************************************************
* 名    称: InitLed()
* 功    能: 设置LED相应的IO口
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void InitLed(void)
{

  P1DIR |= 0x01;               //P1.0定义为输出口  
  P1DIR |= 0x02;               //P1.1定义为输出口 
  P1DIR |= 0x10;               //P1.4定义为输出口 
  asm("NOP");
  
  LedOnOrOff(0);  // 使所有LED灯默认为熄灭状态  
}

/****************************************************************************
* 名    称: InitKey()
* 功    能: 设置按键相应的IO口
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void InitKey(void)
{
  
    P0SEL &= ~0x02;     //设置P0.1为普通IO口  
    P0DIR &= ~0x02;     //按键接在P0.1口上，设P0.1为输入模式 
    P0INP &= ~0x02;     //打开P0.1上拉电阻
  
}

/****************************************************************************
* 名    称: KeyScan()
* 功    能: 读取按键状态
* 入口参数: 无
* 出口参数: 0为抬起   1为按键按下
****************************************************************************/
unsigned char KeyScan(void)
{
    if (KEY1 == 0)
    {
        halWait(20);
        if (KEY1 == 0)
        {
            while(!KEY1); //松手检测
            return 1;     //有按键按下
        }
    }
    
    return 0;             //无按键按下
}

/****************************
//IO初始化程序
*****************************/
void Initial_IO(void)
{
    InitLed();
    InitKey();
}


void initDma(void);
/****************************************************************************
* 名    称: InitUart()
* 功    能: 串口初始化函数
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void InitUart(void)
{ 
    PERCFG = 0x00;           //外设控制寄存器 USART 0的IO位置:0为P0口位置1 
    P0SEL = 0x0c;            //P0_2,P0_3用作串口（外设功能）
    P2DIR &= ~0xC0;          //P0优先作为UART0
    
    U0CSR |= 0x80;           //设置为UART方式
    U0GCR |= 11;	     // baud_e		       
    U0BAUD |= 216;           //波特率设为115200
    UTX0IF = 0;              //UART0 TX中断标志初始置位0
    U0CSR |= 0x40;           //允许接收 
}

/****************************************************************************
* 名    称: UartSendString()
* 功    能: 串口发送函数
* 入口参数: Data:发送缓冲区   len:发送长度
* 出口参数: 无
****************************************************************************/
void UartSendString(char *Data, int len)
{
    uint16 i;
    
    for(i=0; i<len; i++)
    {
        U0DBUF = *Data++;
        while(UTX0IF == 0);
        UTX0IF = 0;
    }
      U0DBUF = 0x0d;
        while(UTX0IF == 0);
        UTX0IF = 0;
      U0DBUF = 0x0a;
        while(UTX0IF == 0);
        UTX0IF = 0;
       halWait(600);

}

/******************************************************************************
* @fn  initDma
*
* @brief
*      Initializes components for the DMA transfer application example.
******************************************************************************/
void initDma(void)
{
   SET_MAIN_CLOCK_SOURCE(CRYSTAL);
   
   Initial_IO();
   InitUart();  //调用串口初始化函数   

   UartSendString(&titleString[0], sizeof(titleString));  //显示Title字符串
}


/******************************************************************************
* @fn  dma_main
*
* @brief
*      Sets up the DMA to transfer data between to RAM locations, trigged by
*      external interrupt generated by button S1. Checks validity of data
*      after transfer.
******************************************************************************/
void main(void){
   DMA_DESC dmaChannel;
   char     sourceString[] = "This is a test string used to demonstrate DMA transfer.";
   char     destString[ sizeof(sourceString) ];
   INT8     i;
   INT8     errors = 0;

   initDma();

   //Clearing the destination
   memset(destString, 0, sizeof(destString) );

     // Setting up the DMA channel.
   SET_WORD(dmaChannel.SRCADDRH, dmaChannel.SRCADDRL,   &sourceString); // The start address of the data to be transmitted
   SET_WORD(dmaChannel.DESTADDRH, dmaChannel.DESTADDRL, &destString);   // The start address of the destination.
   SET_WORD(dmaChannel.LENH, dmaChannel.LENL, sizeof(sourceString));    // Setting the number of bytes to transfer.
   dmaChannel.VLEN      = VLEN_USE_LEN;  // Using the length field to determine how many bytes to transfer.
   dmaChannel.PRIORITY  = PRI_HIGH;      // High priority.
   dmaChannel.M8        = M8_USE_8_BITS; // Irrelevant since length is determined by the LENH and LENL.
   dmaChannel.IRQMASK   = FALSE;         // The DMA shall not issue an IRQ upon completion.
   dmaChannel.DESTINC   = DESTINC_1;     // The destination address is to be incremented by 1 after each transfer.
   dmaChannel.SRCINC    = SRCINC_1;      // The source address inremented by 1 byte after each transfer.
   dmaChannel.TRIG      = DMATRIG_NONE;  // The DMA channel will be started manually.
   dmaChannel.TMODE     = TMODE_BLOCK;   // The number of bytes specified by LENH and LENL is transferred.
   dmaChannel.WORDSIZE  = WORDSIZE_BYTE; // One byte is transferred each time.

   while(1){
   // Using DMA channel 0.
   // Setting where the DMA channel is to read the desciptor and arming the DMA channel.
   DMA_SET_ADDR_DESC0(&dmaChannel);
   DMA_ABORT_CHANNEL(0);
   DMA_ARM_CHANNEL(0);


   //Waiting for the user to start the transfer.

   UartSendString(&hintString[0], sizeof(hintString)); //显示按键提示字符串
   while(!KeyScan());
   halWait(255);

   // Clearing all DMA complete flags and starting the transfer.
   DMAIRQ = 0x00;
   DMA_START_CHANNEL(0);

   // Waiting for the DMA to finish.
   while(!(DMAIRQ & DMA_CHANNEL_0));

   // Verifying that data is transferred correctly
   for(i=0;i<sizeof(sourceString);i++)
   {
     if(sourceString[i] != destString[i])
         errors++;
   }

   //显示DMA传输结果
   if(errors == 0){
     UartSendString(&goodString[0], sizeof(goodString)); //显示成功字符串
     LED1=1;
   }
   else{
       UartSendString(&badString[0], sizeof(badString)); //显示失败字符串
   }
  }

}

