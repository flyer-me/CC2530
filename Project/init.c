//初始化和中断处理
#include"init.h"
unsigned char flag_KEY;      // 程序运行标志，1：KEY1/2：KEY2/3：KEY3
unsigned char GetData = 0;	 //GetData命令指示
unsigned short t1_count = 0; //Timer1溢出次数计数
unsigned char LED = 0;       //LED闪烁标识

int i = 0;                    //UART命令字符计数
char req_Buff[9] = "GetData#";//UART命令判断
uchar txNext;                //UART完成标志
char RxBuf[9];               //UART接收缓存
unsigned char RxCount = 0;   //UART接收计数

unsigned char adcdata[]=" 0.0V";      //ADC测量
uchar adcComplete = 0;       //ADC测量完成指示
float num;                   //ADC测量计算变量
unsigned char temp[2] = "00"; 
uint adc = 0;

/****************************************************************************
* 名    称: Initial_IO()
* 功    能: IO初始化：P0 P1设置为输出   
****************************************************************************/
void Initial_IO(void)
{
    P0DIR |= 0xff;     //P0输出
    P1DIR |= 0xff;     //P1输出
}
/****************************************************************************
* 名    称: LedOnOrOff()
* 功    能: 点亮或熄灭所有LED灯    
* 入口参数: mode为1时LED灯亮  mode为0时LED灯灭
****************************************************************************/
void LedOnOrOff(uchar mode)
{
    LED1 = mode;
    LED2 = mode;
    LED3 = mode;
}
/****************************************************************************
* 名    称: InitLed()
* 功    能: 设置LED灯相应的IO口
****************************************************************************/
void InitLed()
{

  P1DIR |= 0x01;               //P1.0定义为输出口  
  P1DIR |= 0x02;               //P1.1定义为输出口 
  P1DIR |= 0x10;               //P1.4定义为输出口 
  LedOnOrOff(0);      //使所有LED灯默认为熄灭状态
}
/****************************************************************************
* 名    称: InitUart()
* 功    能: 串口初始化函数
****************************************************************************/
void InitUart(void)
{
    PERCFG = 0x00;           //外设控制寄存器 USART 0的IO位置:0为P0口位置1
    P0SEL |= 0x0c;            //P0_2,P0_3用作串口（外设功能）
    P2DIR &= ~0xC0;          //P0优先作为UART0

    U0CSR |= 0x80;           //设置为UART方式
    U0GCR |= 12;	     // baud_e
    U0BAUD |= 216;           //波特率设为115200 16MHz时钟
    UTX0IF = 0;              //UART0 TX中断标志初始置位0
    U0CSR |= 0x40;           //允许接收
    //修改 
    //使能串口发送
    IEN2 |= 0x04; //开USART0发送(TX)中断
    IEN0 |= 0x84; //开总中断允许接收(RX)中断
    EA=1;
}
/****************************************************************************
* 名    称: InitT1()
* 功    能: 定时器初始化，系统不配置工作时钟时默认为16MHz
****************************************************************************/
void InitT1()
{
  T1CC0L = 0xd4;        //设置最大计数值的低8位
  T1CC0H = 0x30;        //设置最大计数值的高8位   0x30d4 = 12500 128分频为0.1s
  T1CCTL0 |= 0x04;      //开启通道0的输出比较模式
  T1IE = 1;             //使能定时器1中断
  T1OVFIM = 1;          //使能定时器1溢出中断
  EA = 1;               //使能总中断
  T1CTL = 0x0e;         ////设置模模式，计数开始
}

/****************************************************************
*函数功能 ：初始化ADC
****************************************************************/
void InitialADC()
{
  P0SEL  |= 0x10;	  //设置P0.4为外设IO口
  P0DIR  &= ~ 0x10; //设置P0.4为输入I/O
  IEN0 |= 0x02;     //中断使能 IEN0.ADCIE=1
  EA = 1;

  ADCCON1 &= ~0x80;		//清EOC标志
  APCFG  |= 0x10;     //设置P0.4为模拟I/O
  ADCCON3 = 0xb4;		  //AIN4通道    参考电电源电压   12位ENOB
  ADCCON1 = 0X30;	    //停止A/D
  ADCCON1 |= 0X40;	  //ADCCON1.ST=1，启动A/D
}
/****************************************************************************
* 名    称: DelayMS()
* 功    能: 以毫秒为单位延时，系统时钟不配置时默认为16M(用示波器测量相当精确)
* 入口参数: msec 延时参数，值越大，延时越久
****************************************************************************/
void DelayMS(uint msec)
{ 
    uint i,j;
    
    for (i=0; i<msec; i++)
        for (j=0; j<535; j++);
        {
          asm("NOP"); // asm是内嵌汇编，nop执行一个指令周期
          asm("NOP");
          asm("NOP");
        }
}
/****************************************************************************
* 名    称: InitKey()
* 功    能: 设置KEY相应的IO口，采用中断方式 
****************************************************************************/
void InitKey()
{   
  //KEY相关端口均使用默认通用I/O 无需设置

  //P0IE = 1; // 允许P0口中断
  IEN1 = 0x20; // 允许P0口中断
  IEN2 = 0x02; // 允许 P2 口中断

  P0IEN |= 0x82;  // P0_7 P0_1 中断使能
  P2IEN |= 0x01;  // P2_0      中断使能  
  PICTL |= 0x09;  // P2_0 P0_7 P0_1  下降沿触发 

  P0IFG = 0x00;   // 初始化中断标志位
  P2IFG = 0x00;   // 初始化中断标志位
  EA = 1;         //使能总中断
}
/****************************************************************************
* 名    称: P0_ISR(void) 中断处理函数 
* 描    述: #pragma vector = 中断向量，紧接着是中断处理程序
****************************************************************************/
#pragma vector = P0INT_VECTOR    
__interrupt void P0_INT(void) 
{ 
    if( P0IFG & 0x80 )   //按键P0_7中断
    {
      DelayMS(10);       //延时去抖     
       if(KEY3==0)       
       {
          flag_KEY = 3;  //产生中断保存中断状态
       }  
    } 
    if( P0IFG & 0x02 )  //按键P0_1中断
    {
      DelayMS(10);       //延时去抖     
       if(KEY1==0)       
       {
          flag_KEY = 1;     //产生中断保存中断状态
       }  
    }
    P0IFG &= ~ 0x82;  //清Pin中断标志
    P0IF = 0;              //清端口0中断标志
} 
/****************************************************************************
* 名    称: P0_ISR(void) 中断处理函数 
* 描    述: #pragma vector = 中断向量，紧接着是中断处理程序
****************************************************************************/
#pragma vector = P2INT_VECTOR  
__interrupt void P2_INT(void) 
{ 
    if( P2IFG & 0x01 )  //按键P2_0中断
    {
      DelayMS(10);       //延时去抖     
       if(KEY2==0)       
       {
          flag_KEY = 2;  //产生中断保存中断状态
       }       
     
    P2IFG &= ~ 0x01;             //清Pin中断标志
    P2IF = 0;              //清端口2中断标志
    }  
}
/****************************************************************************
* UART中断处理函数
****************************************************************************/
#pragma vector = UTX0_VECTOR  //发送
__interrupt void UART0TX_ISR(void) 
{ 
  txNext=1;
  UTX0IF = 0; // 清中断标志
}
#pragma vector = URX0_VECTOR  //接收
__interrupt void UART0RX_ISR(void) 
{
  if(RxCount>=9)
    RxCount = 0;
  RxBuf[RxCount] = U0DBUF; //取出接收到字节

  if(RxBuf[RxCount]==req_Buff[i])
  {
    i++;
    if(i>=8)  //前7位与命令一致，收到命令
    {
      i = 0;
      GetData = 1;
    }
  }  
  RxCount++;
  URX0IF = 0;             // 清中断标志
 
}
/****************************************************************************
* 名    称: UartSendString()
* 功    能: 串口发送函数
* 入口参数: Data:发送缓冲区   len:发送长度
****************************************************************************/
void UartTX_Send_String(char *Data,int len) 
{
  int i;
  for(i=0;i<len;i++) 
  {
    txNext=0;
    U0DBUF=*Data++;
    while(txNext==0); 
   }
  //U0DBUF='\n';
  while(txNext==0);
}
/****************************************************************************
* 定时器T1中断处理函数
****************************************************************************/
#pragma vector=T1_VECTOR
__interrupt void T1_INT(void)
{
   T1STAT &= ~0x20;         //清除定时器1溢出中断标志位
   t1_count++;
   if(t1_count%5 == 0)      //LED按0.5s周期闪烁
   {
     LED = !LED;
   }
   if(t1_count>=60000)   //避免溢出
   {
     t1_count = 0; 
   }
}
/****************************************************************************
* ADC中断处理函数
****************************************************************************/
#pragma vector = ADC_VECTOR
__interrupt void ADC_ISR(void)
{ 
  temp[1] = ADCL;
  temp[0] = ADCH;
  
  adc |= (uint)temp[1];
  adc |= ( (uint) temp[0] )<<8;
  adc >>= 2; // ADCL[1:0]不使用
  num = adc*3.3/8192;//参考电压为3.3V,12位有效位
  adcdata[1] = (char)(num)%10+48;
  adcdata[3] = (char)(num*10)%10+48;
  adcComplete = 1; //设置转换完成的全局变量	
  adc = 0;         //在下一次转换前清零
}